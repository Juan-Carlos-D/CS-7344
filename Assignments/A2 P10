# selective_repeat_sim.py  (final conservative RX: never ACK out-of-window)
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Tuple
import random, itertools

# ----------------------------
# PDUs and CRC-16/CCITT-FALSE
# ----------------------------
@dataclass
class PDU:
    kind: str                 # 'DATA', 'ACK', 'NACK'
    seq: Optional[int]        # DATA seq or ACK/NACK target seq
    payload: bytes = b''
    crc: int = 0
    sent_at: Optional[int] = None
    id: int = field(default_factory=itertools.count().__next__)

def crc16_ccitt(data: bytes, poly=0x1021, init=0xFFFF) -> int:
    crc = init
    for b in data:
        crc ^= b << 8
        for _ in range(8):
            if crc & 0x8000:
                crc = ((crc << 1) & 0xFFFF) ^ poly
            else:
                crc = (crc << 1) & 0xFFFF
    return crc

def build_pdu(kind: str, seq: Optional[int], payload: bytes=b'') -> PDU:
    header = f"{kind}:{seq if seq is not None else -1}:".encode()
    return PDU(kind=kind, seq=seq, payload=payload, crc=crc16_ccitt(header + payload))

# ----------------------------
# Unreliable Channel
# ----------------------------
class Channel:
    def __init__(self, p_loss=0.10, p_bit_error=0.02, seed=42, rtt=4):
        self.p_loss = p_loss
        self.p_bit_error = p_bit_error
        self.random = random.Random(seed)
        self.rtt = rtt

    def transmit(self, pdu: PDU, now: int, log: List[str]) -> Optional[Tuple[int, PDU]]:
        if self.random.random() < self.p_loss:
            log.append(f"[t={now}] {pdu.kind}[{pdu.seq}] **lost** on channel")
            return None

        # Corrupt only the payload bytes we “see” at the other end (seq/kind unchanged)
        corrupted = False
        raw = bytearray(pdu.payload)
        for i in range(len(raw)):
            if self.random.random() < self.p_bit_error:
                raw[i] ^= 1 << self.random.randrange(8)
                corrupted = True

        recv = PDU(kind=pdu.kind, seq=pdu.seq, payload=bytes(raw), crc=pdu.crc)
        delay = self.rtt // 2 + self.random.randint(0, 2)
        arrival = now + delay
        log.append(f"[t={now}] {pdu.kind}[{pdu.seq}] sent -> arrives {'corrupted' if corrupted else 'ok'} at t={arrival}")
        return arrival, recv

# ----------------------------
# Selective Repeat ARQ
# ----------------------------
class SelectiveRepeatSimulator:
    def __init__(
        self,
        frames: List[bytes],
        k_bits=3,
        window_size=None,   # default W = N/2
        timeout=12,
        p_loss=0.10,
        p_bit_error=0.02,
        seed=7,
        rtt=4
    ):
        assert len(frames) >= 7, "Provide at least 7 frames."
        self.N = 1 << k_bits
        self.W = window_size if window_size is not None else self.N // 2
        assert self.W <= self.N // 2, "Selective Repeat requires W <= N/2."

        self.frames = frames
        self.timeout = timeout
        self.channel = Channel(p_loss=p_loss, p_bit_error=p_bit_error, seed=seed, rtt=rtt)

        self.now = 0
        self.log: List[str] = []
        self.inflight: List[Tuple[int, PDU, bool]] = []  # (arrival_time, pdu, to_sender?)

        # sender
        self.send_index = 0
        self.unacked: Dict[int, Tuple[PDU, int, int]] = {}  # seq -> (pdu, sent_at, frame_idx)

        # receiver
        self.recv_expected = 0
        self.recv_buffer: Dict[int, PDU] = {}
        self.delivered: List[bytes] = []
        self.nacked_once: set[int] = set()  # remember which expected seq we already NACKed

    # inclusive circular membership
    def _in_window(self, seq: int, base: int, W: int) -> bool:
        end = (base + W - 1) % self.N
        if base <= end:
            return base <= seq <= end
        return seq >= base or seq <= end

    # ---------- main tick ----------
    def tick(self):
        # sender: push new data while window has space
        while self.send_index < len(self.frames) and len(self.unacked) < self.W:
            seq = self.send_index % self.N
            pdu = build_pdu('DATA', seq, self.frames[self.send_index])
            pdu.sent_at = self.now
            self.unacked[seq] = (pdu, self.now, self.send_index)
            self.send_index += 1
            r = self.channel.transmit(pdu, self.now, self.log)
            if r:
                self.inflight.append((r[0], r[1], False))

        # deliver arrivals at this tick
        arrivals = [e for e in self.inflight if e[0] == self.now]
        self.inflight = [e for e in self.inflight if e[0] != self.now]
        for _, pdu, to_sender in arrivals:
            if to_sender:
                self._handle_at_sender(pdu)
            else:
                self._handle_at_receiver(pdu)

        # per-frame timeouts
        for seq, (pdu, tsent, idx) in list(self.unacked.items()):
            if self.now - tsent >= self.timeout:
                self.log.append(f"[t={self.now}] TIMEOUT data[{seq}] -> retransmit")
                self.unacked[seq] = (pdu, self.now, idx)
                r = self.channel.transmit(pdu, self.now, self.log)
                if r:
                    self.inflight.append((r[0], r[1], False))

        self.now += 1

    # ---------- receiver ----------
    def _handle_at_receiver(self, pdu: PDU):
        # CRC check against original header+payload
        header = f"{pdu.kind}:{pdu.seq if pdu.seq is not None else -1}:".encode()
        ok = (crc16_ccitt(header + pdu.payload) == pdu.crc)
        if not ok:
            self.log.append(f"[t={self.now}] Receiver: {pdu.kind}[{pdu.seq}] **corrupted** -> drop")
            if pdu.kind == 'DATA' and self.recv_expected not in self.nacked_once:
                nack = build_pdu('NACK', self.recv_expected)
                r = self.channel.transmit(nack, self.now, self.log)
                if r: self.inflight.append((r[0], r[1], True))
                self.nacked_once.add(self.recv_expected)
            return

        self.log.append(f"[t={self.now}] Receiver: {pdu.kind}[{pdu.seq}] received ok")
        if pdu.kind != 'DATA':
            return

        seq = pdu.seq
        # Case A: in-window -> buffer + ACK
        if self._in_window(seq, self.recv_expected, self.W):
            if seq not in self.recv_buffer:
                self.recv_buffer[seq] = pdu

            ack = build_pdu('ACK', seq)
            r = self.channel.transmit(ack, self.now, self.log)
            if r: self.inflight.append((r[0], r[1], True))

            # deliver in-order
            while self.recv_expected in self.recv_buffer:
                dpdu = self.recv_buffer.pop(self.recv_expected)
                self.delivered.append(dpdu.payload)
                self.log.append(f"[t={self.now}] Receiver: **DELIVER** data[{self.recv_expected}] to app")
                self.recv_expected = (self.recv_expected + 1) % self.N
                # new hole -> allow a new NACK if needed
                self.nacked_once.discard(self.recv_expected)

            # gap? NACK once
            if (self.recv_expected not in self.recv_buffer
                and any(s != self.recv_expected for s in self.recv_buffer)
                and self.recv_expected not in self.nacked_once):
                nack = build_pdu('NACK', self.recv_expected)
                r = self.channel.transmit(nack, self.now, self.log)
                if r: self.inflight.append((r[0], r[1], True))
                self.nacked_once.add(self.recv_expected)

        # Case B: out-of-window -> DO NOT ACK; NACK base once and drop
        else:
            self.log.append(f"[t={self.now}] Receiver: DATA[{seq}] **out-of-window** (base={self.recv_expected}, W={self.W}) -> drop")
            if self.recv_expected not in self.nacked_once:
                nack = build_pdu('NACK', self.recv_expected)
                r = self.channel.transmit(nack, self.now, self.log)
                if r: self.inflight.append((r[0], r[1], True))
                self.nacked_once.add(self.recv_expected)

    # ---------- sender ----------
    def _handle_at_sender(self, pdu: PDU):
        header = f"{pdu.kind}:{pdu.seq if pdu.seq is not None else -1}:".encode()
        ok = (crc16_ccitt(header + pdu.payload) == pdu.crc)
        if not ok:
            self.log.append(f"[t={self.now}] Sender: {pdu.kind}[{pdu.seq}] **corrupted** -> drop")
            return

        self.log.append(f"[t={self.now}] Sender: {pdu.kind}[{pdu.seq}] received ok")

        if pdu.kind == 'ACK':
            # only clear if still outstanding
            if pdu.seq in self.unacked:
                del self.unacked[pdu.seq]
                self.log.append(f"[t={self.now}] Sender: ACKed data[{pdu.seq}]")

        elif pdu.kind == 'NACK':
            # fast retransmit if outstanding
            if pdu.seq in self.unacked:
                data_pdu, _, idx = self.unacked[pdu.seq]
                self.log.append(f"[t={self.now}] Sender: NACK for data[{pdu.seq}] -> fast retransmit")
                self.unacked[pdu.seq] = (data_pdu, self.now, idx)
                r = self.channel.transmit(data_pdu, self.now, self.log)
                if r: self.inflight.append((r[0], r[1], False))
            # if it's already ACKed, ignore

    # ---------- termination ----------
    def done(self):
        return (
            len(self.delivered) == len(self.frames)
            and not self.unacked
            and not self.inflight
            and self.send_index >= len(self.frames)
        )

    def run(self, max_ticks=1000):
        STALL_LIMIT = 300
        stagnant = 0

        def snap():
            return (len(self.delivered), len(self.unacked), len(self.inflight), self.send_index, self.recv_expected)

        before = snap()
        while not self.done() and self.now < max_ticks:
            self.tick()
            after = snap()
            stagnant = stagnant + 1 if after == before else 0
            if stagnant >= STALL_LIMIT:
                self.log.append(f"[t={self.now}] **STALL** detected (no progress for {STALL_LIMIT} ticks) — stopping.")
                break
            before = after

        finished = "YES" if self.done() else "NO"
        self.log.append(f"[t={self.now}] Simulation finished={finished}, delivered={len(self.delivered)}/{len(self.frames)}")
        return "\n".join(self.log), [p.decode(errors='ignore') for p in self.delivered], self.now

# ----------------------------
# Example
# ----------------------------
if __name__ == "__main__":
    frames = [f"Frame {i}".encode() for i in range(8)]
    sim = SelectiveRepeatSimulator(
        frames=frames,
        k_bits=3,       # N=8
        window_size=4,  # W <= N/2
        timeout=12,
        p_loss=0.12,
        p_bit_error=0.02,
        seed=9,
        rtt=4
    )
    status_log, delivered_order, ticks = sim.run(max_ticks=1000)
    print("---- STATUS LOG ----")
    print(status_log)
    print("\n---- DELIVERY ORDER ----")
    print(delivered_order)
    print(f"\nCompleted in {ticks} ticks, delivered {len(delivered_order)} frames.")
